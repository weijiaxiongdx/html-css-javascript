<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
            .btn{
                background-color: skyblue;
            }
        </style>
    </head>

    <body>
        <button class="btn">按钮1</button>
        <button>按钮2</button>
        <button>按钮3</button>
        <button onclick="alert('行内JavaScript')">按钮4</button><br>

        <!-- JavaScript
          1.是什么
            JavaScript是一种运行在客户端(浏览器)的编程语言
          2.组成
            2.1ECMAScript
               规定了JS基础语法核心知识
            2.2Web APIs
               2.2.1DOM
                    DOM：文档对象模型，用来操作文档，比如对页面元素进行移动、添加删除等
                    DOM树：将HTML文档以树状结构直观的表现出来，称之为文档树或DOM树。整个树中，最上层的对象就是document对象，页面所有内容都在document对象中
                    DOM对象：浏览器根据HTML标签生成的JS对象。任何一个标签都是一个JS对象，所有的标签属性都可以在对应的JS对象上找到，修改这个对象的属性会自动映射到对应的标签上
                    获取DOM元素：1.根据CSS选择器来获取DOM元素，如document.querySelectorAll(‘CSS选择器’)
               2.2.2BOM    
                    浏览器对象模型，用来操作浏览器，比如页面弹窗、检测窗口宽度、存储数据到浏览器等。包括DOM对象，最上层为windown对象(一般省略不写)，结构如下
                    window
                      navigator
                        记录了浏览器自身的信息，常用属性和方法如下
                        userAgent：检测浏览器的版本及平台。如检测是否为安卓或苹果端，如果是则跳转到移动端
                      location
                        href属性：获取完整的URL地址，对其赋值时用于地址的跳转
                        search属性：获取地址中的查询参数(符号？后面的部分)
                        hash属性：获取地址中的hash值(符号#后面的部分)
                        reload：用来刷新当前页面，传入参数true表示强制刷新
                      document
                      history
                        主要用来管理历史记录，该对象与浏览器地址栏操作相对应，如前进、后退、历史记录等
                        back：后退
                        forward：前进
                        go(n)：前进后退，n=1表示前进一个页面、n=-1表示后退一个页面
                      screen
          3.书写位置(与CSS类似)
            3.1行内JavaScript
               代码写在标签内部
            3.2内部JavaScript
               直接写html文件里，用script标签包住
               规范写法：script标签写在结束body上面。因为浏览器会按照代码在文件中的顺序加载HTML，如果先加载的JavaScript期望修改下方的HMTL，那么这个动作可能由于HMTL尚未被加载而失效
                       因此，将JavaScript代码写在HTML页面底部附近通常是最好的策略
            3.3外部JavaScript
               代码写在以.js结尾的文件里，在HTML页面中通过script引入.js文件
               外部JavaScript会使代码更加有序、更易于复用，没有了脚本的混合，HMTL更加易读，所以建议使用外部JavaScript
          4.结束符
            使用英文的分号作为结束符，实际开发中，可写可不写，浏览器(JavaScript引擎)可以自动推断语句的结束位置
            实际开发中，越来越多的人主张不写结束符。为了风格统一，结束符要么每句都写，要么每句都不写(按照团队要求)
          5.JavaScript输入和输出语法
            5.1输出语法
               5.1.1输出语法1
                    document.write('')，向body输出内容，如果内容中有标签，会被解析中网面元素
               5.1.2输出语法2
                    alert('')   
               5.1.3输出语法3
                    console.log('')  
            5.2输入语法
               5.2.1输入语法1
                    prompt('')
          6.JavaScript代码执行顺序
            按HTML文档流顺序执行JavaScript，但alert和prompt会跳过页面渲染先被执行
          7.变量  
            7.1概念
               是计算机存储数据的容器，通俗地说，就是一个装东西的盒子
            7.2声明及赋值
               先声明再赋值
                 let age
                 age = 18   
               声明的同时直接赋值
                 let age = 18  
            7.3规则
               不能使用关键字
               字母严格区别大小写
               只能使用数字、字母、下划线、$，且不能以数字开头  
            7.4规范
               起名要有意义
               遵守小驼峰命名法：第一个单词首字母小写，后面每个单词首字母大写 
            7.5let与var的区别
                var可以先使用再声明(变量会提升)，这是不合理的。let没有该问题
                var声明过的变量可以重复声明，这是不合理的。let没有该问题
                var存在变量提升、全局变量、没有块级作用域
            7.6变量提升
               允许变量在声明之前就被访问，仅存在于var声明的变量，也就是var声明的变量(不包括赋值)会提升到当前作用域的最前面
               因为初学者经常花很多时间才能习惯变量提升，还经常会出现一些意想不到的bug，所以ES6引入地块级作用域，使用let或const声明变量，让代码写法更加规范和人性化    
          8.常量
            8.1概念
               使用const声明的变量称为常量。声明的同时必须赋值
            8.2使用场景
               当某个变量永远不会改变的时候，就可以使用const来声明，而不是let  
          9.数据类型
            9.0弱数据类型
               JavaScript是弱数据类型语言，即变量到底属于哪种类型，只有在赋值后才能确认。Java是强类型语言
            9.1基本数据类型
               number：数字型，可以是整数、小数、正数、负数、NaN
                       NaN代表一个计算错误，它是一个不正确的或未定义的数据操作所得到的结果。NaN是粘性的，任何对NaN的操作都会返回NaN
                       数字型在浏览器控制台中显示为蓝色
               string：字符串型
                       通过单引号、双引号、反引号(`)包裹的数据都叫字符串。单引号和双引号没有本质区别，推荐使用单引号
                       单引号和双引号可以互相嵌套，但是不可以自己嵌套自己。外双内单或外单内双
                       字符串型在浏览器控制台中显示为黑色
               boolean：布尔型
               undefined：未定义型
                          声明变量未赋值就直接使用了，此时输出undefined
               null：空类型
                     赋值了但内容为空
            9.2引用数据类型 
               object对象  
            9.3数据类型检测
               9.3.1运算符方式
                    typeof x
               9.3.2函数形式     
                    typeof(x)
          10.函数 
             10.1匿名函数
                 匿名函数没有名字，无法直接使用，可通过以下两种方式来使用匿名函数
                 函数表达式：将匿名函数赋值给一个变量，通过变量名称进行调用。匿名函数必须先声明再调用，而具名函数的调用可以放到任何地方
                 立即执行函数：不需调用(本质上也有调用)，立即执行。避免全局变量之间的污染  
             10.2函数提升
                 允许函数在声明之前被调用
                 会把所有函数声明提升到当前作用域的最前面，使用函数表达式定义的函数不会被提升(毕竟是变量)  
             10.3函数参数 
                 10.3.1动态参数
                       arguments是函数内部内置的伪数组(有索引号但没有一般数组常用的方法)变量，它包含了调用函数时传入的所有实参。见“动态参数”例子
                 10.3.2剩余参数 
                       将不定量的参数表示为一个数组(这是一个真数组)。见“剩余参数”例子  
                       剩余参数写在函数的最后，它之前能匹配几个参数就匹配几个参数，匹配不上的就使用剩余参数来接收，更加灵活。推荐使用剩余参数，而不是动态参数
             10.4ES6箭头函数 
                 10.4.1目的
                       让函数的写法更简洁(比函数表达式更简洁)且不绑定this
                 10.4.2使用场景
                       用在本来需要匿名函数的地方
                 10.4.3注意
                       箭头函数属于表达式函数，不存在函数提升
                       箭头函数没有arguments参数，但是有剩余参数
                       箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this
                       其它见箭头函数相关例子 
             10.5内置构造函数
                 Object
                 Array
                 String
                 Number                           
          11.逻辑中断
             逻辑运算符里的短路，只存在于&&和||，当满足一定的条件会让右边的代码不执行
          12.对象
             12.1内置对象
                 Math
             12.2环境对象
                 指的是函数内部特殊的变量this，代表着当前函数运行时所处的环境
                 粗略规则：谁调用就指谁。直接调用函数，如fn()，相当于window.fn()，这时this就是window  
             12.3创建对象三种方式 
                 12.3.1利用字面量创建对象
                 12.3.2利用new Object创建对象(内置的构造函数)
                 12.3.3利用自定义的构造函数创建对象
          13.事件      
             13.1事件监听
                 13.1.1三要素
                       事件源：被事件触发的DOM元素
                       事件类型：触发方式，如click等
                       事件调用函数：触发事件后要做的事 
                 13.1.2版本
                       DOM L0：DOM的第一个版本，L表示Level。事件源.on事件 = function (){}
                       DOM L1：DOM级别1于1998年10月1号成为W3C推荐标准
                       DOM L2：事件源.addEventListener(事件，事件处理函数)  
                       DOM L3：在DOM L2的基础上重新定义了一些事件，也添加一些新事件类型   
                   
                       二者区别：on的方式会被覆盖，后写的函数会覆盖先写的同名函数(想像成变量赋值)
                               addEventListener的方式会绑定多次(就是不会疲覆盖)，拥有事件更多特性，推荐使用
             13.2事件流/事件捕获/事件冒泡
                 事件流指的是事件完整执行过程中的流动路径
                 当事件触发时，会经历两个阶段，分别是捕获阶段和冒泡阶段。捕获阶段指事件的执行从顶层document对象一层一层到最里层具体的对象，冒泡阶段过程相反，默认使用的是冒泡机制。若使用L0事件监听，则只有冒泡阶段
                 addEventListener(事件类型，事件处理函数，是否使用捕获机制默认为false)，不写第三个参数，默认就是冒泡机制
                 可以使用obj.stopPropagation()阻断事件流动传播，在冒泡阶段和捕获阶段都有效  
             13.3事件委托 
                 优点：减少注册次数，提高程序性能
                 原理：利用事件冒泡的特性，给父元素注册事件，当触发子元素的时候，会冒泡到父元素，从而触发父元素的事件     
          14.插件
             14.1swiper插件(开源、免费、强大的触摸滑动插件) 
                 官网：https://www.swiper.com.cn/  
                 使用：官网->菜单栏->获取Swiper，下载Swiper->将下载的zip文件中相关的css文件和js文件放到自己的项目中->“在线演示”菜单栏中找到自己想要的效果
                      然后点击“在新窗口中打开”并右键从网页源代码中复制相关的html、css、js到自己的页面中，或者通过在线演示中的序号从下载的文件中的demo文件夹中找到对应的html文件并复制相关的代码到自己的文件中   
          15.JavaScript执行机制 
             单线程执行，同一个时间只能做一件事，所有任务需要排队，如果JS执行时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉
             为了解决这个问题，利用多核CPU的计算能力，HTML5提出了Web Worker标准，允许JavaScript创建多个线程，于是JavaScript中出现了同步和异步 
             同步任务都在主线程上执行，形成一个执行栈
             JS的异步是通过回调函数实现的，异步任务会放到任务队列中，异步任务主要有以下三种类型
                 1.普通事件，如click、resize等  
                 2.资源加载，如load、error等
                 3.定时器，如setInterval、setTimeout等
             
             执行顺序：先执行执行栈中的同步任务，一旦执行栈中所有同步任务执行完毕，系统就会按次序读取任务队列中的任务到执行栈中并执行   
          16.本地存储
             16.1LocalStorage 
                 16.1.1作用
                       可以将数据永久存储在本地(用户的电脑)，除非手动删除，否则关闭页面也会存在
                 16.1.2特性
                       以键值对的形式存储、可以多窗口(页面)共享(同种浏览器同域名可共享) 
             16.2SessionStorage
                 关闭浏览窗口数据就没了，其它跟LocalStorage一样  
          17.作用域
             17.1局部作用域
                 17.1.1函数作用域
                       在函数内部声明的变量只能在函数内部被访问，外部无法直接访问
                 17.1.2块作用域
                       在JavaScript中使用{}包裹的代码称为代码块，代码块内部声明的变量，外部有可能访问不到(let和const声明的变量会产生块作用域，外部无法访问。但var声明的变量不会产生块作用域，外部可以访问)
             17.2全局作用域  
                 <script>标签和.js文件的最外层就是全局作用域，在此声明的变量，函数内部也能访问
                 为window对象动态添加的属性默认也是全局的，不推荐这么做
                 函数中未使用任何关键字声明的变量也是全局的，不推荐这么做
                 尽可能少地声明全局变量，防止全局变量污染
          18.作用域链
             本质是底层的变量查找机制。在函数执行时，会优先在当前函数作用中查找变量，如果当前作用域中找不到则会逐级查找父级作用域，直到全局使用域
          19.垃圾回收机制(Garbage Collection，GC) 
             19.1概述
                 JS中内存的分配和回收都是自动完成的，内存在不使用的时候就会被垃圾回收器自动回收
             19.2内存的生命周期
                 分配：声明变量、函数、对象的时候，系统会自动分配内存
                 使用：即读写内存，也就是使用变量、函数等
                 回收：使用完后，由垃圾回收器自动回收不再使用的内存。全局变量一般不会回收，关闭页面时回收 
             19.3垃圾回收算法
                 引用计数法：IE采用的是引用计数法。存在循环引用问题，会导致内存泄漏
                 标记清除法：现代的浏览器不再使用引用计数法了，而是使用基于标记清除算法的某些改进算法   
          20.闭包(Closure) 
             20.1概念
                 一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的使用域  
                 简单理解：闭包=内层函数+内层函数中使用了外层函数的变量   
             21.2作用
                 封闭数据，提供操作，使得外部也可以访问函数内部的变量
             21.3应用
                 实现数据的私有，如统计函数调用次数：计算的变量不要使用全局变量，而是定义在函数里面，写法类似于“闭包常用的形式”对应的例子
             21.4可能引起的问题
                 内存泄漏，如“闭包常用的形式”例子，虽然变量a是定义在outer函数内部，但外部函数fun是全局变量，页面关闭才会回收，页面没有关闭就还用着变量a，所以可能造成内存泄漏
          21.解构赋值
             21.1概念
                 解构赋值是一种快速为变量赋值的简洁语法，本质上就是为变量赋值
             21.2分类
                 21.2.1数组解构
                       是将数组的单元值快速批量赋值给一系列变量的简洁语法
                       典型应用：交换两个变量的值
                 21.2.2对象解构
                       是将对象的属性和方法快速批量赋值给一系列变量的简洁语法
          22.面向对象编程三大特性
             封装：通过构造函数实现封装
             继承：通过原型实现继承
             多态 
          23.原型对象 
             23.1概念 
                 构造函数通过原型分配的函数是所有对象共享的
                 JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，称为原型对象 
                 原型对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存
                 可以把那些不变的方法直接定义在prototype对象上，这样所有的对象实例就可以共享这些方法
                 构造函数和原型对象中的this都指向实例化的对象
             
                 总结：原型可以使方法共享
             23.2constructor
                 指定原型对象对应的构造函数 
             23.3对象原型  
                 每个对象都有一个__proto__属性，指向其构造函数的原型对象。实例对象之所以可以使用构造函数上prototype原型对象的属性和方法，就是因为__proto__的存在 
                 __proto__是JS的非标准属性，浏览中显示的是[[prototype]]，和__proto__是一个意思   

                 注意：__proto__前后各有两个短线
             23.4原型继承 
                 见“原型继承”例子 
             23.5原型链  
          24.拷贝
             24.1浅拷贝
                 拷贝对象 
                     Object.assign()
                     {...obj}
                 拷贝数组 
                     Array.prototype.concat()
                     [...arr]       
             24.2深拷贝
                 自己通过递归实现
                 Lodash工具库中的_.cloneDeep方法
                 JSON.parse(JSON.stringify(obj)) 
          25.异常处理
          26.改变this指向
             JavaScript中允许指定函数中this的指向，以下3个方法可以动态指定普通函数中this的指向
             call()：调用函数且可改变this指向
             apply()：调用函数且可改变this指向
             bind()：不会调用函数但可改变this指向
          27.性能优化  
             27.1防抖动(debounce)
                 概念：单位时间内，频繁触发事件，只执行最后一次。如3秒内触发多次，只执行最后一次
                 实现：Lodash工具库中的_.debounce方法
                      自己通过setTimeout实现
             27.2节流(throttle)
                 概念：单位时间内，频繁触发事件，只执行一次。如3秒内触发多次，只执行第一次
                 实现：Lodash工具库中的_.throttle方法
                      自己通过setTimeout实现
                 经典场景：记录上一次视频播放的位置
                         ontimeupdate：事件在音频/视频当前的播放位置发生改变时触发
                         onloadeddata：事件在当前帧的数据加载完成且还没有足够的数据播放音频/视频的下一帧时触发     

                         整体思路：ontimeupdate这个函数可以做节流，可以设置一秒执行一次且把当前时间(video.currentTime)存储到本地存储localStorage中
                                 下次打开页面，触发onloadeddata事件时，从本地存储中取出之前保存的时间，让视频从取出的时间播放，如果没有则默认从0秒开始播放
        -->


        <!-- 初体验 -->
        <!-- 内部JavaScript  --> 
        <script> 
            let btns = document.querySelectorAll('button') // querySelectorAll选择匹配的所有元素
            // console.dir(btns) // 打印对象
            for(let i = 0; i < btns.length; i++){
                btns[i].addEventListener('click',function(){
                    document.querySelector('.btn').className = '' // querySelector选择匹配的第一个元素
                    this.className = 'btn'
                })
            }
        </script>

        <script src="./js/outer.js">
            // 这里不要写代码，写了也会被忽略
        </script> <!-- 外部JavaScript  -->
        
        <script>
            document.write('输出语法1，向body输出内容')
            document.write('<h1>h1标题</h1>')
            // let userInput = prompt('prompt会跳过页面渲染先被执行')
            // console.log(userInput)
            // alert('alert会跳过页面渲染先被执行')

            console.log(name) // var变量可以先使用再声明，能正常打印出"张三123"
            var name = '张三123'
            // var name = '重复声明name变量'

            const PI = 3.14 // 常量，声明的同时必须赋值
            // PI = 3 // 不能给常量重新赋值，此处执行报错
            console.log(PI)

            let age = 20
            document.write(`我今年${age}`) // 模板字符串，必须使用反引号包裹

            // let weidingyi
            // console.log(weidingyi) // 未定义类型，输出undefined

            console.log(2-'2') // 隐式类型转换，- * /都存在隐式类型转换。第二个2由字符串类型变成了数字类型，结果为0
            console.log(+'123') // 隐式类型转换， +作为正号解析可以转换成数字型。该例把字符串类型变成了数字类型，结果为数字123

            console.log(Number('123')) // 显示类型转换，结果为数字123
            console.log(parseInt('456px')) // 显示类型转换，px不认识直接去掉，结果为数字456
            console.log(parseFloat('78.89px')); // 显示类型转换，px不认识直接去掉，结果为数字78.89

            // let a = +prompt('隐式类型转换') // 隐式类型转换
            // console.log(a)


            // let arr = [1,6,90,34,21,0]
            // arr.sort(function(a,b){ // 升序
            //   return a - b
            // })
            // console.log('升序序列：',arr)

            //  arr.sort(function(a,b){ // 降序
            //   return b - a
            // })
            // console.log('降序序列：',arr)


            // function fn(){
            //    num = 300 // 没有声明，直接赋值，就提升成全局变量了，强烈不推荐这么做
            // }
            // fn()
            // console.log(num)

            // let fn = function () { // 匿名函数之函数表达式：将匿名函数赋值给一个变量，称为函数表达式
            //    console.log('匿名函数测试')
            // }
            // console.log(fn())


            // 多个立即执行函数必须要用分号分隔，分号要么都写在尾部，要么都写在头部。如果都写在尾部，则第一个匿名函数的上一行代码尾部需要加上分号
            // (function () { 
            //    console.log('匿名函数之立即执行函数方式一');
            // })();

            // (function(){
            //    console.log('匿名函数之立即执行函数方式二');
            // }());


            // 闭包简单写法
            // function outer(){
            //    let a = 10
            //    function inner(){
            //       console.log(a) // 在这一行打一个断点，当代码执行这一行时，浏览器->Sources->右侧Scope区域中会出现Closure(outer)，它里面有a:10
            //                      // 浏览器里显示的是Closure(outer)，可不可以说outer就是闭包？？？
            //    }
            //    inner()
            // }
            // outer()

            // 闭包常用的形式：外部访问函数内部的变量
            // function outer(){
            //    let a = 0
            //    function inner(){
            //       a++
            //       console.log(`函数被调用了${a}次`)
            //    }

            //    return inner
            // }

            // const fun = outer()
            // fun() // 输出10，相当于外部fun函数访问了outer函数内部的变量


            // 函数提升，声明之前先调用了
            // funPromote()
            // function funPromote(){
            //    console.log('函数提升')
            // }

            // // 动态参数
            // function sum(){
            //    let s = 0
            //    for(let i = 0; i < arguments.length; i++){
            //       s+=arguments[i]
            //    }

            //    console.log('和为:',s)
            // }
            // sum(1,4,6)
            // sum(1,4,6,23,40)


            // 剩余参数
            // function getSum2(a,b,...other){ // 三个点后的参数名称随便定义
            //    console.log('剩余参数测试：',other)
            // }
            // getSum2(1,2,3,4,5)


            // 展开运算符
            // const arr = [1,2,3,4,5,6]
            // console.log(arr)
            // console.log(...arr) // 展开运算符，直接输出是不带逗号的：1 2 3 4 5 6。直接这么用没有意义
            // console.log(Math.max(...arr)) // 展开运算符使用场景一：求数组最大值或最小值。这么写其实是带逗号的，官方也说是带逗号的

            // const arr2 = [8,9]
            // const arr3 = [...arr, ...arr2] // 展开运算符使用场景二：合并数组
            // console.log(arr3)

            // 箭头函数用法一
            // const fn = () => {
            //    console.log('箭头函数')
            // }
            // fn()

            // 箭头函数用法二：只有一个参数的时候可以省略小括号
            // const fn2 = p => {
            //    console.log('箭头函数一个参数',p)
            // }
            // fn2(1)

            // 箭头函数用法三：只有一行代码的时候可以省略大括号
            // const fn3 = p => console.log('箭头函数一行代码',p)
            // fn3(1)

            // 箭头函数用法四：只有一行代码的时候可以省略大括号且无需写return，可直接返回值
            // const fn4 = (x,y) => x + y
            // console.log(fn4(1,8))

            // 箭头函数用法五：直接返回一个对象，必须使用小括号括起来
            // const fn5 = (username) => ({name: username})
            // console.log(fn5('张三'))

            // 箭头函数this
            // const fn = () => {
            //    console.log('箭头函数this',this) // 自己没有this，沿用上一层作用域中的this，也就是window
            // }
            // fn()

            // 数组解构赋值
            // const arr = [5,12,8]
            // const [a,b,c] = arr // 批量赋值
            // console.log('数组解构赋值',a,b,c)

            // 数组解构赋值-典型应用，交换两个变量的值
            // let x = 1
            // let y = 2; // 这里的分号必须加
            // ;[y,x] = [x,y] // 或者加在这一行的开头。反正就是要和上一句隔开
            // ;[y=0,x=0] = [x,y] // 可以给变量设置默认值，值少变量多的时候防止undefined
            // console.log('交换两个变量的值后',x,y)


            // 对象解构
            // const {address,sex} = {address: '湖北',sex: '男'} // 变量名必须与对象中的属性名一致
            // console.log('对象解构',address,sex)

            // const {hobby:newHobby,height} = {hobby: '乒乓球',height: 178} // 可以对变量重新命名，旧变量名:新变量名
            // console.log('对象解构-对就量重新命名',newHobby,height)

            // 数组对象解构
            // const pig = [
            //     {
            //         name2: '佩奇',
            //         weight: 350
            //     }
            // ]
            // const [{name2,weight}] = pig
            // console.log('数组对象解构',name2,weight)


            // 自定义构造函数
            // function Pig(name, age){ // 函数名首字母一般大写
            //     this.name = name
            //     this.age = age
            // }
            // console.log(new Pig('佩奇'),7) // 使用new关键字进行实例化


            // 原型对象
            // console.log('构造函数上的原型对象',Pig.prototype)
            // Pig.prototype.eat = function(){
            //     console.log('给构造函数上的原型对象上添加方法，是所有对象共享的')
            // }

            // const p1 = new Pig('佩奇',1)
            // const p2 = new Pig('佩奇2',2)
            // console.log('实例对象指向的原型对象',p1.__proto__)
            // console.log(p1.eat===p2.eat) // true，证明原型上的方法上是所有实例对象共享的


            // Pig.prototype = { // 这样写，原型对象上的constructor属性就没有了(相当于覆盖了原型对象原来的内容)，必须重新指回原型对象对应的构造函数
            //     constructor: Pig, // 重新指回原型对象对应的构造函数，否则constructor没有了
            //     sing: function(){
            //         console.log('唱歌')
            //     },
            //     dance: function(){
            //         console.log('跳舞')
            //     }
            // }
            // console.log(Pig.prototype)


            // 原型继承
            function Person() { // 定义公共属性，也就是父类
                this.eyes = 2,
                this.head = 1
            }

            function Man (){

            }

            function Woman (){

            }

            // const m = new Man()
            // const w = new Woman()
            // console.log('原型继承前',m,w) // 继承前都是空对象

            // Man通过原型来继承Person
            // 子类的原型 = new 父类
            // Man.prototype = new Person() // 这里是覆盖，下面必须重新指回构造函数
            // Man.prototype.constructor = Man // 重新指回原型对应的构造函数
            // const m = new Man()
            // console.log('原型继承后',m) // 继承后，Man的原型上就有公共属性了

            // Woman.prototype = new Person()
            // Woman.prototype.constructor = Woman
            // const w = new Woman()
            // console.log('原型继承后2',w)

            // 异常处理
            function fn(x,y){
                if(!x || !y){
                    // throw '没有参数'
                    throw new Error('没有参数') // 会输出堆栈信息
                }

                return x+y
            }
            fn()

           
        </script>
    </body>
</html>