<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
            .btn{
                background-color: skyblue;
            }
        </style>
    </head>

    <body>
        <button class="btn">按钮1</button>
        <button>按钮2</button>
        <button>按钮3</button>
        <button onclick="alert('行内JavaScript')">按钮4</button><br>

        <!-- JavaScript
          1.是什么
            JavaScript是一种运行在客户端(浏览器)的编程语言
          2.组成
            2.1ECMAScript
               规定了JS基础语法核心知识
            2.2Web APIs
               2.2.1DOM
                    DOM：文档对象模型，用来操作文档，比如对页面元素进行移动、添加删除等
                    DOM树：将HTML文档以树状结构直观的表现出来，称之为文档树或DOM树。整个树中，最上层的对象就是document对象，页面所有内容都在document对象中
                    DOM对象：浏览器根据HTML标签生成的JS对象。任何一个标签都是一个JS对象，所有的标签属性都可以在对应的JS对象上找到，修改这个对象的属性会自动映射到对应的标签上
                    获取DOM元素：1.根据CSS选择器来获取DOM元素，如document.querySelectorAll(‘CSS选择器’)
               2.2.2BOM    
                    浏览器对象模型，用来操作浏览器，比如页面弹窗、检测窗口宽度、存储数据到浏览器等。包括DOM对象，最上层为windown对象(一般省略不写)，结构如下
                    window
                      navigator
                        记录了浏览器自身的信息，常用属性和方法如下
                        userAgent：检测浏览器的版本及平台。如检测是否为安卓或苹果端，如果是则跳转到移动端
                      location
                        href属性：获取完整的URL地址，对其赋值时用于地址的跳转
                        search属性：获取地址中的查询参数(符号？后面的部分)
                        hash属性：获取地址中的hash值(符号#后面的部分)
                        reload：用来刷新当前页面，传入参数true表示强制刷新
                      document
                      history
                        主要用来管理历史记录，该对象与浏览器地址栏操作相对应，如前进、后退、历史记录等
                        back：后退
                        forward：前进
                        go(n)：前进后退，n=1表示前进一个页面、n=-1表示后退一个页面
                      screen
          3.书写位置(与CSS类似)
            3.1行内JavaScript
               代码写在标签内部
            3.2内部JavaScript
               直接写html文件里，用script标签包住
               规范写法：script标签写在结束body上面。因为浏览器会按照代码在文件中的顺序加载HTML，如果先加载的JavaScript期望修改下方的HMTL，那么这个动作可能由于HMTL尚未被加载而失效
                       因此，将JavaScript代码写在HTML页面底部附近通常是最好的策略
            3.3外部JavaScript
               代码写在以.js结尾的文件里，在HTML页面中通过script引入.js文件
               外部JavaScript会使代码更加有序、更易于复用，没有了脚本的混合，HMTL更加易读，所以建议使用外部JavaScript
          4.结束符
            使用英文的分号作为结束符，实际开发中，可写可不写，浏览器(JavaScript引擎)可以自动推断语句的结束位置
            实际开发中，越来越多的人主张不写结束符。为了风格统一，结束符要么每句都写，要么每句都不写(按照团队要求)
          5.JavaScript输入和输出语法
            5.1输出语法
               5.1.1输出语法1
                    document.write('')，向body输出内容，如果内容中有标签，会被解析中网面元素
               5.1.2输出语法2
                    alert('')   
               5.1.3输出语法3
                    console.log('')  
            5.2输入语法
               5.2.1输入语法1
                    prompt('')
          6.JavaScript代码执行顺序
            按HTML文档流顺序执行JavaScript，但alert和prompt会跳过页面渲染先被执行
          7.变量  
            7.1概念
               是计算机存储数据的容器，通俗地说，就是一个装东西的盒子
            7.2声明及赋值
               先声明再赋值
                 let age
                 age = 18   
               声明的同时直接赋值
                 let age = 18  
            7.3规则
               不能使用关键字
               字母严格区别大小写
               只能使用数字、字母、下划线、$，且不能以数字开头  
            7.4规范
               起名要有意义
               遵守小驼峰命名法：第一个单词首字母小写，后面每个单词首字母大写 
            7.5let与var的区别
                var可以先使用再声明(变量会提升)，这是不合理的。let没有该问题
                var声明过的变量可以重复声明，这是不合理的。let没有该问题
                var存在变量提升、全局变量、没有块级作用域
          8.常量
            8.1概念
               使用const声明的变量称为常量。声明的同时必须赋值
            8.2使用场景
               当某个变量永远不会改变的时候，就可以使用const来声明，而不是let  
          9.数据类型
            9.0弱数据类型
               JavaScript是弱数据类型语言，即变量到底属于哪种类型，只有在赋值后才能确认。Java是强类型语言
            9.1基本数据类型
               number：数字型，可以是整数、小数、正数、负数、NaN
                       NaN代表一个计算错误，它是一个不正确的或未定义的数据操作所得到的结果。NaN是粘性的，任何对NaN的操作都会返回NaN
                       数字型在浏览器控制台中显示为蓝色
               string：字符串型
                       通过单引号、双引号、反引号(`)包裹的数据都叫字符串。单引号和双引号没有本质区别，推荐使用单引号
                       单引号和双引号可以互相嵌套，但是不可以自己嵌套自己。外双内单或外单内双
                       字符串型在浏览器控制台中显示为黑色
               boolean：布尔型
               undefined：未定义型
                          声明变量未赋值就直接使用了，此时输出undefined
               null：空类型
                     赋值了但内容为空
            9.2引用数据类型 
               object对象  
            9.3数据类型检测
               9.3.1运算符方式
                    typeof x
               9.3.2函数形式     
                    typeof(x)
          10.函数 
             10.1匿名函数
                 匿名函数没有名字，无法直接使用，可通过以下两种方式来使用匿名函数
                 函数表达式：将匿名函数赋值给一个变量，通过变量名称进行调用。匿名函数必须先声明再调用，而具名函数的调用可以放到任何地方
                 立即执行函数：不需调用(本质上也有调用)，立即执行。避免全局变量之间的污染  
          11.逻辑中断
             逻辑运算符里的短路，只存在于&&和||，当满足一定的条件会让右边的代码不执行
          12.对象
             12.内置对象
                Math
             13.环境对象
                指的是函数内部特殊的变量this，代表着当前函数运行时所处的环境
                粗略规则：谁调用就指谁。直接调用函数，如fn()，相当于window.fn()，这时this就是window  
          13.事件      
             13.1事件监听
                 13.1.1三要素
                       事件源：被事件触发的DOM元素
                       事件类型：触发方式，如click等
                       事件调用函数：触发事件后要做的事 
                 13.1.2版本
                       DOM L0：DOM的第一个版本，L表示Level。事件源.on事件 = function (){}
                       DOM L1：DOM级别1于1998年10月1号成为W3C推荐标准
                       DOM L2：事件源.addEventListener(事件，事件处理函数)  
                       DOM L3：在DOM L2的基础上重新定义了一些事件，也添加一些新事件类型   
                   
                       二者区别：on的方式会被覆盖，后写的函数会覆盖先写的同名函数(想像成变量赋值)
                               addEventListener的方式会绑定多次(就是不会疲覆盖)，拥有事件更多特性，推荐使用
             13.2事件流/事件捕获/事件冒泡
                 事件流指的是事件完整执行过程中的流动路径
                 当事件触发时，会经历两个阶段，分别是捕获阶段和冒泡阶段。捕获阶段指事件的执行从顶层document对象一层一层到最里层具体的对象，冒泡阶段过程相反，默认使用的是冒泡机制。若使用L0事件监听，则只有冒泡阶段
                 addEventListener(事件类型，事件处理函数，是否使用捕获机制默认为false)，不写第三个参数，默认就是冒泡机制
                 可以使用obj.stopPropagation()阻断事件流动传播，在冒泡阶段和捕获阶段都有效  
             13.3事件委托 
                 优点：减少注册次数，提高程序性能
                 原理：利用事件冒泡的特性，给父元素注册事件，当触发子元素的时候，会冒泡到父元素，从而触发父元素的事件     
          14.插件
             14.1swiper插件(开源、免费、强大的触摸滑动插件) 
                 官网：https://www.swiper.com.cn/  
                 使用：官网->菜单栏->获取Swiper，下载Swiper->将下载的zip文件中相关的css文件和js文件放到自己的项目中->“在线演示”菜单栏中找到自己想要的效果
                      然后点击“在新窗口中打开”并右键从网页源代码中复制相关的html、css、js到自己的页面中，或者通过在线演示中的序号从下载的文件中的demo文件夹中找到对应的html文件并复制相关的代码到自己的文件中   
          15.JavaScript执行机制 
             单线程执行，同一个时间只能做一件事，所有任务需要排队，如果JS执行时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉
             为了解决这个问题，利用多核CPU的计算能力，HTML5提出了Web Worker标准，允许JavaScript创建多个线程，于是JavaScript中出现了同步和异步 
             同步任务都在主线程上执行，形成一个执行栈
             JS的异步是通过回调函数实现的，异步任务会放到任务队列中，异步任务主要有以下三种类型
                 1.普通事件，如click、resize等  
                 2.资源加载，如load、error等
                 3.定时器，如setInterval、setTimeout等
             
             执行顺序：先执行执行栈中的同步任务，一旦执行栈中所有同步任务执行完毕，系统就会按次序读取任务队列中的任务到执行栈中并执行   
          16.本地存储
             16.1LocalStorage 
                 16.1.1作用
                       可以将数据永久存储在本地(用户的电脑)，除非手动删除，否则关闭页面也会存在
                 16.1.2特性
                       以键值对的形式存储、可以多窗口(页面)共享(同种浏览器同域名可共享) 
             16.2SessionStorage
                 关闭浏览窗口数据就没了，其它跟LocalStorage一样          
        -->


        <!-- 初体验 -->
        <!-- 内部JavaScript  --> 
        <script> 
            let btns = document.querySelectorAll('button') // querySelectorAll选择匹配的所有元素
            // console.dir(btns) // 打印对象
            for(let i = 0; i < btns.length; i++){
                btns[i].addEventListener('click',function(){
                    document.querySelector('.btn').className = '' // querySelector选择匹配的第一个元素
                    this.className = 'btn'
                })
            }
        </script>

        <script src="./js/outer.js">
            // 这里不要写代码，写了也会被忽略
        </script> <!-- 外部JavaScript  -->
        
        <script>
            document.write('输出语法1，向body输出内容')
            document.write('<h1>h1标题</h1>')
            // let userInput = prompt('prompt会跳过页面渲染先被执行')
            // console.log(userInput)
            // alert('alert会跳过页面渲染先被执行')

            console.log(name) // var变量可以先使用再声明，能正常打印出"张三123"
            var name = '张三123'
            // var name = '重复声明name变量'

            const PI = 3.14 // 常量，声明的同时必须赋值
            // PI = 3 // 不能给常量重新赋值，此处执行报错
            console.log(PI)

            let age = 20
            document.write(`我今年${age}`) // 模板字符串，必须使用反引号包裹

            // let weidingyi
            // console.log(weidingyi) // 未定义类型，输出undefined

            console.log(2-'2') // 隐式类型转换，- * /都存在隐式类型转换。第二个2由字符串类型变成了数字类型，结果为0
            console.log(+'123') // 隐式类型转换， +作为正号解析可以转换成数字型。该例把字符串类型变成了数字类型，结果为数字123

            console.log(Number('123')) // 显示类型转换，结果为数字123
            console.log(parseInt('456px')) // 显示类型转换，px不认识直接去掉，结果为数字456
            console.log(parseFloat('78.89px')); // 显示类型转换，px不认识直接去掉，结果为数字78.89

            // let a = +prompt('隐式类型转换') // 隐式类型转换
            // console.log(a)


            // let arr = [1,6,90,34,21,0]
            // arr.sort(function(a,b){ // 升序
            //   return a - b
            // })
            // console.log('升序序列：',arr)

            //  arr.sort(function(a,b){ // 降序
            //   return b - a
            // })
            // console.log('降序序列：',arr)


            // function fn(){
            //    num = 300 // 没有声明，直接赋值，就提升成全局变量了，强烈不推荐这么做
            // }
            // fn()
            // console.log(num)

            // let fn = function () { // 匿名函数之函数表达式：将匿名函数赋值给一个变量，称为函数表达式
            //    console.log('匿名函数测试')
            // }
            // console.log(fn())


            // 多个立即执行函数必须要用分号分隔，分号要么都写在尾部，要么都写在头部。如果都写在尾部，则第一个匿名函数的上一行代码尾部需要加上分号
            // (function () { 
            //    console.log('匿名函数之立即执行函数方式一');
            // })();

            // (function(){
            //    console.log('匿名函数之立即执行函数方式二');
            // }());

        </script>
    </body>
</html>